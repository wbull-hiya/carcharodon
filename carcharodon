#!/usr/bin/env bash
#
# carcharodon - CLI tool for the Carcharodon spoofed call API
#
# Usage: carcharodon <command> [options]
#

set -euo pipefail

VERSION="1.3.0"
API_BASE="${CARCHARODON_API_URL:-https://carcharodon.toolsv3.us-west-2.wtpgs.net}"
API_USER="${CARCHARODON_USER:-${USER}@hiya.com}"

# Colors (disabled if not a terminal or NO_COLOR is set)
if [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    CYAN=''
    BOLD=''
    DIM=''
    NC=''
fi

# Output flags
JSON_OUTPUT=false
QUIET_OUTPUT=false

# Retry settings
MAX_RETRIES=3
RETRY_DELAY=2

#######################################
# Embedded test numbers database
# Format: number|type|level|category|identity|description
#######################################
TEST_NUMBERS='
+14014008249|connect|||suppressed|cps: pre-auth warning
+15127461048|connect|||suppressed|cps: do not originate
+17865818702|connect|||suppressed|cps test: full profile
+19254754734|connect|||suppressed|cps: pre-auth block
+16505573867|override|ok|none|suppressed|
+17864225541|override|uncertain|none|suppressed|
+16613024569|override|uncertain|telemarketer|suppressed|
+19732734932|override|uncertain|survey|suppressed|
+19012214676|override|spam|survey|suppressed|
+17083180306|override|spam|robocaller|suppressed|
+15034107797|override|spam|nonprofit|suppressed|
+17862506692|override|spam|telemarketer|suppressed|
+16163595513|override|fraud|none|suppressed|
+16194340965|override|fraud|extortion|suppressed|
+17795482973|override|fraud|tax scam|suppressed|
+15039801231|override|fraud|tech support scam|suppressed|
+15074125952|override|fraud|scam or fraud|suppressed|
+17862506697|override|ok|none|hiya test number|
+16502273199|override|uncertain|none|hiya test number|
+16304571676|override|uncertain|survey|hiya test number|
+13364810806|override|spam|telemarketer|hiya test number|
+16505572500|override|fraud|scam or fraud|hiya test number|
+441599312031|override|ok|none|suppressed|UK
+441485205017|override|uncertain|none|suppressed|UK
+441750432049|override|uncertain|telemarketer|suppressed|UK
+441439377054|override|uncertain|survey|suppressed|UK
+441756802051|override|spam|none|suppressed|UK
+441792720368|override|spam|survey|suppressed|UK
+441677252010|override|spam|robocaller|suppressed|UK
+441789532065|override|spam|nonprofit|suppressed|UK
+441798422021|override|spam|telemarketer|suppressed|UK
+441368908042|override|fraud|none|suppressed|UK
+441764752037|override|fraud|extortion|suppressed|UK
+441786542064|override|fraud|tax scam|suppressed|UK
+441299382089|override|fraud|tech support scam|suppressed|UK
+441764752032|override|fraud|scam or fraud|suppressed|UK
+441756802041|override|ok|none|hiya test number|UK
+441749200173|override|uncertain|none|hiya test number|UK
+441756802047|override|spam|telemarketer|hiya test number|UK
+441456256030|override|fraud|scam or fraud|hiya test number|UK
+12065550175|override|fraud||business|
+12065550176|override|spam||unknown|
+12065550177|override|spam||business|
+12065550178|override|fraud||unknown|
+12065550179|override|fraud||unknown|
+12065550169|override|fraud||unknown|
+12065550110|override|ok||business|
+12065550101|override|ok||person|
+12065550111|override|ok||unknown|
+12065550120|override|uncertain||business|
+12065550121|override|uncertain||business|
+12065550130|override|uncertain||unknown|
+12065550145|override|uncertain||business|
+12065550148|override||||
+12065550149|override|uncertain||unknown|
+19991110006|override|uncertain||business|
+19005550170|override|fraud||unknown|
'

#######################################
# Print error message to stderr
#######################################
error() {
    echo -e "${RED}error:${NC} $*" >&2
}

#######################################
# Print warning message to stderr
#######################################
warn() {
    if [[ "$QUIET_OUTPUT" == "false" ]]; then
        echo -e "${YELLOW}warning:${NC} $*" >&2
    fi
}

#######################################
# Print success message
#######################################
success() {
    if [[ "$QUIET_OUTPUT" == "false" ]]; then
        echo -e "${GREEN}✓${NC} $*"
    fi
}

#######################################
# Print info message
#######################################
info() {
    if [[ "$QUIET_OUTPUT" == "false" ]]; then
        echo -e "${BLUE}→${NC} $*"
    fi
}

#######################################
# Check for required dependencies
#######################################
check_dependencies() {
    local missing=()

    if ! command -v curl &>/dev/null; then
        missing+=("curl")
    fi

    if ! command -v jq &>/dev/null; then
        missing+=("jq")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing required dependencies: ${missing[*]}"
        echo "Install with: brew install ${missing[*]}" >&2
        exit 1
    fi
}

#######################################
# Validate E.164 phone number format
#######################################
validate_e164() {
    local number="$1"
    local label="$2"

    if [[ ! "$number" =~ ^\+[1-9][0-9]{6,14}$ ]]; then
        error "Invalid $label: '$number'"
        echo "  Phone numbers must be in E.164 format (e.g., +12065551234)" >&2
        return 1
    fi
}


#######################################
# Make API request with retry logic
# Usage: api_request METHOD ENDPOINT [DATA] [EXTRA_HEADER]
#######################################
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local extra_header="${4:-}"
    local attempt=1
    local response
    local http_code
    local body

    while [[ $attempt -le $MAX_RETRIES ]]; do
        local curl_args=(
            -sk
            -w "\n%{http_code}"
            -X "$method"
            -H "User: $API_USER"
            -H "Content-Type: application/json"
        )

        # Add extra header if provided
        if [[ -n "$extra_header" ]]; then
            curl_args+=(-H "$extra_header")
        fi

        if [[ -n "$data" ]]; then
            curl_args+=(-d "$data")
        fi

        response=$(curl "${curl_args[@]}" "${API_BASE}${endpoint}" 2>/dev/null) || {
            if [[ $attempt -lt $MAX_RETRIES ]]; then
                warn "Request failed, retrying in ${RETRY_DELAY}s... (attempt $attempt/$MAX_RETRIES)"
                sleep "$RETRY_DELAY"
                ((attempt++))
                continue
            else
                error "Request failed after $MAX_RETRIES attempts"
                return 1
            fi
        }

        http_code=$(echo "$response" | tail -n1)
        body=$(echo "$response" | sed '$d')

        case "$http_code" in
            2*)
                echo "$body"
                return 0
                ;;
            401)
                error "Authentication failed - check your API key"
                return 1
                ;;
            403)
                error "Access forbidden - insufficient permissions"
                return 1
                ;;
            404)
                error "Resource not found"
                return 1
                ;;
            422)
                local msg
                msg=$(echo "$body" | jq -r '.message // .error // "Validation error"' 2>/dev/null)
                error "Validation error: $msg"
                return 1
                ;;
            429)
                error "Rate limit exceeded - please wait before retrying"
                return 1
                ;;
            500)
                error "Server error - please try again later"
                return 1
                ;;
            503)
                if [[ $attempt -lt $MAX_RETRIES ]]; then
                    warn "Service unavailable, retrying in ${RETRY_DELAY}s... (attempt $attempt/$MAX_RETRIES)"
                    sleep "$RETRY_DELAY"
                    ((attempt++))
                    continue
                else
                    error "Service unavailable after $MAX_RETRIES attempts"
                    return 1
                fi
                ;;
            *)
                error "Unexpected response (HTTP $http_code)"
                if [[ -n "$body" ]]; then
                    echo "$body" >&2
                fi
                return 1
                ;;
        esac
    done
}

#######################################
# Format timestamp table
#######################################
format_timestamps() {
    local json="$1"

    printf "${BOLD}%-25s %-30s${NC}\n" "Event" "Timestamp"
    printf "%-25s %-30s\n" "-------------------------" "------------------------------"

    echo "$json" | jq -r '
        to_entries | .[] |
        "\(.key)\t\(.value)"
    ' | while IFS=$'\t' read -r key value; do
        printf "%-25s %-30s\n" "$key" "$value"
    done
}

#######################################
# Poll call status until complete
#######################################
wait_for_call() {
    local call_id="$1"
    local timeout="${2:-120}"
    local start_time
    start_time=$(date +%s)

    info "Waiting for call to complete..."

    while true; do
        local elapsed
        elapsed=$(($(date +%s) - start_time))

        if [[ $elapsed -ge $timeout ]]; then
            warn "Timeout waiting for call completion"
            return 1
        fi

        local response
        response=$(api_request "GET" "/calls/$call_id") || return 1

        local status
        status=$(echo "$response" | jq -r '.status // "unknown"')

        case "$status" in
            completed|answered)
                if [[ "$JSON_OUTPUT" == "true" ]]; then
                    echo "$response"
                else
                    success "Call completed"
                    echo "$response" | jq -r '"  Status: \(.status)\n  Duration: \(.duration // "N/A")s"'
                fi
                return 0
                ;;
            failed|canceled|cancelled)
                if [[ "$JSON_OUTPUT" == "true" ]]; then
                    echo "$response"
                else
                    error "Call $status"
                    local reason
                    reason=$(echo "$response" | jq -r '.reason // .error // "Unknown reason"')
                    echo "  Reason: $reason" >&2
                fi
                return 1
                ;;
            *)
                sleep 2
                ;;
        esac
    done
}

#######################################
# Get color for level
#######################################
level_color() {
    local level="$1"
    case "$level" in
        ok) echo "$GREEN" ;;
        uncertain) echo "$YELLOW" ;;
        spam) echo "$YELLOW" ;;
        fraud) echo "$RED" ;;
        *) echo "$NC" ;;
    esac
}

#######################################
# Resolve shorthand to phone number
# Supports: spam, fraud, ok, uncertain
# And: fraud:tax-scam, spam:robocaller, etc.
#######################################
resolve_number_shorthand() {
    local shorthand="$1"
    local level=""
    local category=""

    # Check if it's already a phone number
    if [[ "$shorthand" =~ ^\+ ]]; then
        echo "$shorthand"
        return 0
    fi

    # Parse level:category format
    if [[ "$shorthand" == *:* ]]; then
        level="${shorthand%%:*}"
        category="${shorthand#*:}"
        # Normalize category (replace - with space)
        category="${category//-/ }"
    else
        level="$shorthand"
    fi

    # Normalize level
    level=$(echo "$level" | tr '[:upper:]' '[:lower:]')

    # Build filter
    local matches=()
    while IFS='|' read -r number type nlevel ncategory nidentity ndesc; do
        [[ -z "$number" ]] && continue

        # Match level
        if [[ -n "$level" ]] && [[ "$nlevel" != "$level" ]]; then
            continue
        fi

        # Match category if specified
        if [[ -n "$category" ]]; then
            local norm_cat
            norm_cat=$(echo "$ncategory" | tr '[:upper:]' '[:lower:]')
            if [[ "$norm_cat" != *"$category"* ]]; then
                continue
            fi
        fi

        matches+=("$number")
    done <<< "$TEST_NUMBERS"

    if [[ ${#matches[@]} -eq 0 ]]; then
        error "No test number found matching '$shorthand'"
        echo "  Run 'carcharodon numbers' to see available test numbers" >&2
        return 1
    fi

    # Pick random from matches
    local idx=$((RANDOM % ${#matches[@]}))
    echo "${matches[$idx]}"
}

#######################################
# Command: numbers
#######################################
cmd_numbers() {
    local filter_level=""
    local filter_category=""
    local filter_region=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -l|--level)
                filter_level="$2"
                shift 2
                ;;
            -c|--category)
                filter_category="$2"
                shift 2
                ;;
            -r|--region)
                filter_region="$2"
                shift 2
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --quiet|-q)
                QUIET_OUTPUT=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                echo "Usage: carcharodon numbers [--level <level>] [--category <cat>] [--region us|uk]" >&2
                exit 1
                ;;
        esac
    done

    filter_level=$(echo "$filter_level" | tr '[:upper:]' '[:lower:]')
    filter_category=$(echo "$filter_category" | tr '[:upper:]' '[:lower:]')
    filter_region=$(echo "$filter_region" | tr '[:upper:]' '[:lower:]')

    local json_arr="["
    local first=true

    if [[ "$JSON_OUTPUT" != "true" ]] && [[ "$QUIET_OUTPUT" != "true" ]]; then
        printf "${BOLD}%-16s %-10s %-18s %-20s${NC}\n" "Number" "Level" "Category" "Identity"
        printf "%-16s %-10s %-18s %-20s\n" "----------------" "----------" "------------------" "--------------------"
    fi

    while IFS='|' read -r number type level category identity desc; do
        [[ -z "$number" ]] && continue

        # Apply region filter
        if [[ -n "$filter_region" ]]; then
            if [[ "$filter_region" == "uk" ]] && [[ "$number" != +44* ]]; then
                continue
            fi
            if [[ "$filter_region" == "us" ]] && [[ "$number" == +44* ]]; then
                continue
            fi
        fi

        # Apply level filter
        if [[ -n "$filter_level" ]]; then
            local norm_level
            norm_level=$(echo "$level" | tr '[:upper:]' '[:lower:]')
            if [[ "$norm_level" != "$filter_level" ]]; then
                continue
            fi
        fi

        # Apply category filter
        if [[ -n "$filter_category" ]]; then
            local norm_cat
            norm_cat=$(echo "$category" | tr '[:upper:]' '[:lower:]')
            if [[ "$norm_cat" != *"$filter_category"* ]]; then
                continue
            fi
        fi

        if [[ "$JSON_OUTPUT" == "true" ]]; then
            [[ "$first" != "true" ]] && json_arr+=","
            first=false
            json_arr+=$(jq -n \
                --arg num "$number" \
                --arg type "$type" \
                --arg level "$level" \
                --arg cat "$category" \
                --arg id "$identity" \
                --arg desc "$desc" \
                '{number: $num, type: $type, level: $level, category: $cat, identity: $id, description: $desc}')
        elif [[ "$QUIET_OUTPUT" == "true" ]]; then
            echo "$number"
        else
            local color
            color=$(level_color "$level")
            printf "%-16s ${color}%-10s${NC} %-18s %-20s\n" "$number" "${level:-—}" "${category:-—}" "${identity:-—}"
        fi
    done <<< "$TEST_NUMBERS"

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        json_arr+="]"
        echo "$json_arr" | jq .
    fi
}

#######################################
# Command: call
#######################################
cmd_call() {
    local to_number=""
    local from_number=""
    local cancel_after="35000"
    local trunk=""
    local wait_for_complete=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--to)
                to_number="$2"
                shift 2
                ;;
            -f|--from)
                from_number="$2"
                shift 2
                ;;
            --cancel-after)
                cancel_after="$2"
                shift 2
                ;;
            --trunk)
                trunk="$2"
                shift 2
                ;;
            --wait)
                wait_for_complete=true
                shift
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --quiet|-q)
                QUIET_OUTPUT=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                echo "Usage: carcharodon call -t <to> -f <from|shorthand> [--trunk <name>] [--cancel-after <ms>] [--wait]" >&2
                exit 1
                ;;
        esac
    done

    # Validate trunk if specified
    if [[ -n "$trunk" ]]; then
        case "$trunk" in
            flowroute|telnyx|bandwidth) ;;
            *)
                error "Invalid trunk: '$trunk'"
                echo "  Valid trunks: flowroute, telnyx, bandwidth" >&2
                exit 1
                ;;
        esac
    fi

    if [[ -z "$to_number" ]]; then
        error "Missing required option: -t/--to"
        exit 1
    fi

    if [[ -z "$from_number" ]]; then
        error "Missing required option: -f/--from"
        exit 1
    fi

    validate_e164 "$to_number" "to number" || exit 1

    # Resolve from_number shorthand if needed
    if [[ ! "$from_number" =~ ^\+ ]]; then
        local resolved
        resolved=$(resolve_number_shorthand "$from_number") || exit 1
        info "Using test number: $resolved (${from_number})"
        from_number="$resolved"
    fi

    validate_e164 "$from_number" "from number" || exit 1


    local payload
    payload=$(jq -n \
        --arg to "$to_number" \
        --arg from "$from_number" \
        --argjson cancel "$cancel_after" \
        '{to: $to, from: $from, cancel_after: $cancel}')

    # Build extra headers
    local extra_headers=""
    if [[ -n "$trunk" ]]; then
        extra_headers="Sip-Trunk: $trunk"
    fi

    local response
    response=$(api_request "POST" "/call" "$payload" "$extra_headers") || exit 1

    local call_id
    call_id=$(echo "$response" | jq -r '.id // .callId // empty')

    if [[ -z "$call_id" ]]; then
        error "Failed to get call ID from response"
        echo "$response" >&2
        exit 1
    fi

    if [[ "$QUIET_OUTPUT" == "true" ]]; then
        echo "$call_id"
    elif [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$response"
    else
        success "Call initiated"
        echo "  Call ID: $call_id"
        echo "  To: $to_number"
        echo "  From: $from_number"
        [[ -n "$trunk" ]] && echo "  Trunk: $trunk"
    fi

    if [[ "$wait_for_complete" == "true" ]]; then
        wait_for_call "$call_id"
    fi
}

#######################################
# Command: status
#######################################
cmd_status() {
    local call_id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i|--id)
                call_id="$2"
                shift 2
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --quiet|-q)
                QUIET_OUTPUT=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                echo "Usage: carcharodon status -i <call_id>" >&2
                exit 1
                ;;
        esac
    done

    if [[ -z "$call_id" ]]; then
        error "Missing required option: -i/--id"
        exit 1
    fi


    local response
    response=$(api_request "GET" "/calls/$call_id") || exit 1

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$response"
    elif [[ "$QUIET_OUTPUT" == "true" ]]; then
        # Get latest status code
        echo "$response" | jq -r '[.messages[] | select(.status != null) | .status] | last // "unknown"'
    else
        local msg_count last_status first_ts last_ts from_hdr to_hdr
        msg_count=$(echo "$response" | jq -r '.messages | length')
        last_status=$(echo "$response" | jq -r '[.messages[] | select(.status != null) | .status] | last // "N/A"')
        first_ts=$(echo "$response" | jq -r '.messages | sort_by(.timestamp) | first | .timestamp // "N/A"')
        last_ts=$(echo "$response" | jq -r '.messages | sort_by(.timestamp) | last | .timestamp // "N/A"')
        from_hdr=$(echo "$response" | jq -r '.messages[0].headers.From // "N/A"' | sed 's/.*<sip:\([^@>]*\).*/\1/')
        to_hdr=$(echo "$response" | jq -r '.messages[0].headers.To // "N/A"' | sed 's/.*<sip:\([^@>]*\).*/\1/' | sed 's/.*\*//')

        echo -e "${BOLD}Call Status${NC}"
        echo "  ID:         $call_id"
        echo "  Last Code:  $last_status"
        echo "  From:       $from_hdr"
        echo "  To:         $to_hdr"
        echo "  Messages:   $msg_count"
        echo "  Started:    $first_ts"
        echo "  Last:       $last_ts"
    fi
}

#######################################
# Command: cancel
#######################################
cmd_cancel() {
    local call_id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i|--id)
                call_id="$2"
                shift 2
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --quiet|-q)
                QUIET_OUTPUT=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                echo "Usage: carcharodon cancel -i <call_id>" >&2
                exit 1
                ;;
        esac
    done

    if [[ -z "$call_id" ]]; then
        error "Missing required option: -i/--id"
        exit 1
    fi


    local response
    response=$(api_request "DELETE" "/calls/$call_id") || exit 1

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$response"
    elif [[ "$QUIET_OUTPUT" == "true" ]]; then
        echo "cancelled"
    else
        success "Call cancelled"
        echo "  Call ID: $call_id"
    fi
}

#######################################
# Command: timestamps
#######################################
cmd_timestamps() {
    local call_id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -i|--id)
                call_id="$2"
                shift 2
                ;;
            --json)
                JSON_OUTPUT=true
                shift
                ;;
            --quiet|-q)
                QUIET_OUTPUT=true
                shift
                ;;
            *)
                error "Unknown option: $1"
                echo "Usage: carcharodon timestamps -i <call_id>" >&2
                exit 1
                ;;
        esac
    done

    if [[ -z "$call_id" ]]; then
        error "Missing required option: -i/--id"
        exit 1
    fi


    local response
    response=$(api_request "GET" "/calls/$call_id/timestamps") || exit 1

    if [[ "$JSON_OUTPUT" == "true" ]]; then
        echo "$response"
    elif [[ "$QUIET_OUTPUT" == "true" ]]; then
        echo "$response" | jq -r '.callTimestamps | to_entries[] | "\(.key): \(.value)"'
    else
        echo -e "${BOLD}SIP Timestamps for Call $call_id${NC}"
        echo
        printf "${BOLD}%-20s %-30s${NC}\n" "Event" "Timestamp"
        printf "%-20s %-30s\n" "--------------------" "------------------------------"
        echo "$response" | jq -r '.callTimestamps | to_entries[] | "\(.key)\t\(.value // "—")"' | while IFS=$'\t' read -r key value; do
            printf "%-20s %-30s\n" "$key" "$value"
        done
    fi
}

#######################################
# Show help
#######################################
show_help() {
    cat <<EOF
${BOLD}carcharodon${NC} - CLI tool for the Carcharodon spoofed call API

${BOLD}USAGE:${NC}
    carcharodon <command> [options]

${BOLD}COMMANDS:${NC}
    call        Place a spoofed call
    status      Get call status
    cancel      Cancel an active call
    timestamps  Get SIP timing information
    numbers     List available test numbers

${BOLD}GLOBAL OPTIONS:${NC}
    --json      Output raw JSON
    --quiet, -q Minimal output
    --help, -h  Show this help
    --version   Show version

${BOLD}EXAMPLES:${NC}
    # Place a call with explicit number
    carcharodon call -t +12065551234 -f +18005551234

    # Place a call using test number shorthand
    carcharodon call -t +12065551234 -f spam
    carcharodon call -t +12065551234 -f fraud
    carcharodon call -t +12065551234 -f fraud:tax-scam

    # Use a specific SIP trunk
    carcharodon call -t +12065551234 -f spam --trunk telnyx

    # Place a call and wait for completion
    carcharodon call -t +12065551234 -f +18005551234 --wait

    # Get call status as JSON
    carcharodon status -i abc123 --json

    # Cancel an active call
    carcharodon cancel -i abc123

    # View SIP timestamps
    carcharodon timestamps -i abc123

    # List test numbers
    carcharodon numbers
    carcharodon numbers --level fraud
    carcharodon numbers --level spam --region uk
    carcharodon numbers --category telemarketer

${BOLD}TEST NUMBER SHORTHANDS:${NC}
    ok              Random number with ok level
    uncertain       Random number with uncertain level
    spam            Random spam number
    fraud           Random fraud number
    fraud:tax-scam  Fraud number with specific category
    spam:robocaller Spam number with specific category

${BOLD}ENVIRONMENT:${NC}
    CARCHARODON_USER      User email for API (default: \$USER@hiya.com)
    CARCHARODON_API_URL   API base URL (default: https://carcharodon.toolsv3.us-west-2.wtpgs.net)
    NO_COLOR              Disable colored output

${BOLD}CALL OPTIONS:${NC}
    -t, --to <number>       Destination phone number (E.164 format)
    -f, --from <number>     Caller ID - E.164 number or shorthand (spam, fraud, etc.)
    --trunk <name>          SIP trunk: flowroute (default), telnyx, bandwidth
    --cancel-after <ms>     Auto-cancel timeout in milliseconds (default: 35000)
    --wait                  Wait for call to complete before returning

${BOLD}SIP TRUNKS:${NC}
    flowroute               Default for US numbers
    telnyx                  Alternative trunk
    bandwidth               Auto-selected for UK (+44) numbers

${BOLD}STATUS/CANCEL/TIMESTAMPS OPTIONS:${NC}
    -i, --id <call_id>      Call ID to query

${BOLD}NUMBERS OPTIONS:${NC}
    -l, --level <level>     Filter by level (ok, uncertain, spam, fraud)
    -c, --category <cat>    Filter by category (telemarketer, robocaller, etc.)
    -r, --region <region>   Filter by region (us, uk)
EOF
}

#######################################
# Main entry point
#######################################
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi

    check_dependencies

    case "$1" in
        call)
            shift
            cmd_call "$@"
            ;;
        status)
            shift
            cmd_status "$@"
            ;;
        cancel)
            shift
            cmd_cancel "$@"
            ;;
        timestamps)
            shift
            cmd_timestamps "$@"
            ;;
        numbers)
            shift
            cmd_numbers "$@"
            ;;
        --help|-h|help)
            show_help
            ;;
        --version|-v)
            echo "carcharodon version $VERSION"
            ;;
        *)
            error "Unknown command: $1"
            echo "Run 'carcharodon --help' for usage" >&2
            exit 1
            ;;
    esac
}

main "$@"
